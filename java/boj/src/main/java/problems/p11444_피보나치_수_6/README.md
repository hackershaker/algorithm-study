# 📄 문제 풀이 요약: Fast Doubling Method

## 🚀 문제 요약
- **목표:** N번째 피보나치 수 ($F_N$) 찾기
- **N의 범위:** $N \le 10^{18}$ (매우 큰 자연수)
- **출력:** $F_N \pmod{10^9 + 7}$

## 💡 핵심 아이디어: Fast Doubling (분할 정복을 이용한 거듭제곱)

기존의 순차적 계산($F_{n+2} = F_{n+1} + F_n$)은 $O(N)$의 시간 복잡도를 가지므로
$N \approx 10^{18}$인 경우 **시간 초과**가 발생합니다.

이를 해결하기 위해 **Fast Doubling Method (FDM)**라는 분할 정복 기반의 방법을 사용합니다.
이 방법은 수열의 크기를 반씩 줄여나가면서 빠르게 계산합니다.

### 📜 Fast Doubling 공식

다음 두 가지 관계식을 이용하여 $N$을 $\lfloor N/2 \rfloor$로 줄여나갈 수 있습니다.

$$F_{2k} = F_k \cdot (2F_{k+1} - F_k)$$
$$F_{2k+1} = F_{k+1}^2 + F_k^2$$

## ⏱️ 복잡도
$$O(\log N)$$

---

## 📚 배운 점 및 구현 시 주의사항

### 1) 피보나치의 새로운 관계식 (Fast Doubling)

| 방법 | 관계식 | 시간 복잡도 |
| :--- | :--- | :--- |
| **기존** | $F_{n+2} = F_{n+1} + F_n$ | $O(N)$ |
| **Fast Doubling** | $F_{2k} = F_k \cdot (2F_{k+1} - F_k)$<br>$F_{2k+1} = F_{k+1}^2 + F_k^2$ | $O(\log N)$ |

이 공식은 **인덱스의 절반**을 이용해 한 번에 큰 단계를 뛰어넘어 시간 복잡도를 비약적으로 개선합니다.

### 2) 함수 반환 값 최적화

재귀 함수 `fibo(n)`가 $F_n$ **하나만** 반환하도록 설계하면, $F_{2k}$와 $F_{2k+1}$을 계산하기 위해
${F_k}$와 ${F_{k+1}}$을 모두 필요로 하므로, 특정 값의 계산이 중복되어 비용이 증가합니다.

* **최적화:** `fibo(n)`이 **$F_n$과 $F_{n+1}$ 두 값**을 동시에 반환하도록 설계합니다.
* **효과:** 불필요한 중복 연산을 제거하고, $O(\log N)$의 복잡도를 유지할 수 있게 합니다.

### 3) MOD 연산에서 음수 처리 주의

$F_{2k}$ 공식 중 $(2F_{k+1} - F_k)$ 부분에서 $2F_{k+1} < F_k$ 일 때 **음수**가 발생할 수 있습니다.

**예시:** $\text{MOD} = 100$, $F_{k+1} = 10$, $F_k = 30$ 일 때
$$(2 \cdot 10) - 30 = -10$$

MOD 연산은 보통 양의 정수를 가정하므로, 음수가 발생하면 결과가 깨집니다.

**해결책:** 뺄셈 전에 $\text{MOD}$ 값을 한 번 더해서 **결과가 항상 양수**가 되도록 보장합니다.

$$\left( (2 \cdot F_{k+1} \pmod{\text{MOD}}) - F_k + \text{MOD} \right) \pmod{\text{MOD}}$$

* **예시 적용:**
  $$(20 - 30 + 100) \pmod{100} = 90 \pmod{100} = 90$$